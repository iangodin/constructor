#! /usr/bin/env python
# Copyright (c) 2012 Kimball Thurston
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
#
# Filename: constructor
#
# Author: Kimball Thurston
#
#

import os
import sys
import errno
import string
import subprocess
import optparse

_constructor_extension = ".cns" #".py" # 

# Work around some differences between python 2 and 3
# that we can't just handle generically

if sys.version_info[0] == 3:
    def _iterate( x ):
        return x.items()
else:
    def _iterate( x ):
        return x.iteritems()

class Dependency(object):
    def __init__( self, orderonly ):
        self._dependencies = {}
        self.orderonly = orderonly

    def add_dependency( self, group, dep ):
        if not isinstance( dep, Dependency ):
            Error( "Attempt to add dependency that is not a subclass of Dependency" )

        try:
            deps = self._dependencies[group]
        except KeyError:
            deps = []
            self._dependencies[group] = deps

        found = False
        for d in deps:
            if d is dep:
                found = True
                break
        if not found:
            deps.append( dep )

    def dependencies( self, group ):
        if group in self._dependencies:
            return self._dependencies[group]
        return []
            
class _FileDependency(Dependency):
    def __init__( self, infile, orderonly ):
        super(_FileDependency, self).__init__( orderonly )
        self.filename = infile

class _ExternalPackage(Dependency):
    def __init__( self, name, cflags, iflags, lflags, ver ):
        super(_ExternalPackage, self).__init__( False )
        self.name = name
        self.cflags = cflags.strip()
        self.iflags = iflags.strip()
        self.lflags = lflags.strip()
        self.version = ver.strip()

class _Directory(Dependency):
    def __init__( self, path, relpath, binpath, pardir = None, globs = None ):
        super(_Directory, self).__init__( False )
        self.pardir = pardir
        self.globs = globs
        self.src_dir = path
        self.rel_src_dir = relpath
        self.bin_path = binpath
        self.targets = None
        self.subdirs = {}

    def set_globals( self, globs ):
        self.globs = globs

    def get_globals( self ):
        if self.globs is None:
            return self.pardir.get_globals()
        return self.globs

    def set_bin_dir( self, path ):
        self.bin_path = path
        if len(self.rel_src_dir) > 0:
            self.bin_path = os.path.join( path, self.rel_src_dir )
        for sd in self.subdirs:
            sd.set_bin_dir( path )

    def make_bin_tree( self):
        Info( "make bin tree: %s" % self.bin_path )

    def add_sub_dir( self, name ):
        try:
            dobj = self.subdirs[name]
        except KeyError as e:
            newd = self.rel_src_dir
            if len(newd) > 0:
                newd = os.path.join( newd, name )
            else:
                newd = name

            dobj = _Directory( os.path.join( self.src_dir, name ),
                               newd,
                               os.path.join( self.bin_path, name ),
                               self )
            self.add_dependency( "config", dobj )
            self.subdirs[name] = dobj

        return dobj

    def addToGlobals( self, namespace ):
        if self.globs is None:
            self.globs = self.get_globals().copy()

        new_globs = {}
        all_names = namespace.get( "__all__" )
        if all_names is None:
            for k, v in _iterate( namespace ):
                if k[0] != '_' and k not in self.globs:
                    new_globs[k] = v
        else:
            for k in all_names:
                if k not in self.globs:
                    new_globs[k] = namespace[k]
        self.globs.update( new_globs )

    def _configPassPostProc( curdir, namespace ):
        curdir.addToGlobals( namespace )

class _Rule(object):
    def __init__( self, rargs ):
        self.name = rargs['tag']
        cmd = rargs['cmd']
        if isinstance( cmd, list ):
            command = ""
            for c in cmd:
                command += ' ' + c
        else:
            command = cmd
        self.command = command
        self.description = rargs.get( 'desc' )
        self.use_input_in_desc = rargs.get( 'use_input_in_desc' )
        self.dependency_file = rargs.get( 'depfile' )

        self._use_count = 0

    def addUse( self ):
        self._use_count = self._use_count + 1

    def isUsed( self ):
        return self._use_count > 0

class Target(Dependency):
    def __init__( self, orderonly = False ):
        super(Target, self).__init__( orderonly )
        pass

class FileType(object):
    def __init__( self, ext ):
        self.extension = ext

def _handleFile( f, operation ):
    (base, ext) = os.path.splitext( f )
    handler = _extension_handlers.get( ext )
    if handler is not None:
        return getattr( handler, operation )( f )
    else:
        Error( "No handler defined for extension '%s'" % ext )
    return None

# Produces a list of targets
def Compile( *args ):
    ret = []
    for f in args:
        if isinstance( f, Target ):
            ret.append( f )
        if isinstance( f, (str, basestring) ):
            ret.append( _handleFile( f, "compile" ) )
        elif isinstance( f, list ):
            ret.append( Compile( *f ) )
        elif isinstance( f, tuple ):
            for x in f:
                ret.append( Compile( x ) )
    return ret

class ProcessPhase(object):
    def __init__( self, name, fileroot, optional, postproc = None ):
        self.name = name
        self.file_root = fileroot
        self.optional = optional
        self.post_proc = postproc
        self.cur_dir = None

    def subdir( self, name ):
        if self.cur_dir is None:
            Error( "Attempt to process a sub directory with no current directory" )
        newd = self.cur_dir.add_sub_dir( name )
        self.process_dir( newd )

    def process_dir( self, curdir ):
        oldd = self.cur_dir
        try:
            self.cur_dir = curdir
            global _constructor_extension
            filename = self.file_root + _constructor_extension
            fn = os.path.join( curdir.src_dir, filename )
            namespace = curdir.get_globals().copy()
            with open( fn, "r" ) as f:
                curdir.add_dependency( "config", _FileDependency( fn, False ) )
                exec( compile( f.read() + "\n", filename, 'exec' ), namespace, namespace )
            if self.post_proc:
                self.post_proc( curdir, namespace )
        except IOError as e:
            if e.errno == errno.ENOENT:
                if not self.optional:
                    Error( "Unable to read required file '%s'" % fn )
            else:
                Error( "Unable to read and process file '%s': %s" % (fn, e.strerror) )
        except Exception as e:
            Error( "Error processing file '%s': %s" % ( fn, str(e) ) )
        finally:
            self.cur_dir = oldd

class Generator(ProcessPhase):
    def __init__( self, name ):
        super( Generator, self ).__init__( name, None, False, None )

    def process_dir( self, curdir ):
        Error( "Sub-class of generator should override process_dir" )

class Ninja(Generator):
    def __init__( self ):
        super( Ninja, self ).__init__( "ninja" )

    def process_dir( self, curdir ):
        curdir.make_bin_tree()
        config_file_list = []
        def _traverse_config_files( deps ):
            for d in deps:
                if isinstance( d, _Directory ):
                    _traverse_config_files( d.dependencies( "config" ) )
                else:
                    config_file_list.append( d.filename )
        _traverse_config_files( curdir.dependencies( "config" ) )
        for cf in config_file_list:
            Info( "Build depends on: %s" % cf )

_generators = { "ninja": Ninja }

class _BuildTree(object):
    """The master class for constructor that stores the parsed contents for
       an entire build tree"""
    _singleton = None

    def __init__( self ):
        if _BuildTree._singleton is not None:
            Error( "More than one Build Tree object instantiated" )
        _BuildTree._singleton = self

        self.build = None
        self.build_dir = None
        self.build_set = {}

        self.generator = "ninja"

        self.phases = [ ProcessPhase( "config", "config", True, _Directory._configPassPostProc ),
                        ProcessPhase( "build", "build", False ) ]

        self.user_features = None
        self.user_feature_defs = None

        self.parser = optparse.OptionParser( usage="usage: %prog [options]", version="%prog 1.0" )
        self.parser.add_option( '--build',
                                 help='Allows one to specify build type',
                                 type="string",
                                 default=None )
        self.parser.add_option( '--build-dir',
                                 type="string",
                                 help='Specifies output directory used for building (by default <current directory>/<build-type-outlocation>)' )
        self.parser.add_option( '--source-dir',
                                 type="string",
                                 help='Specifies the source root to find build files (by default <current directory>)' )
        self.parser.add_option( '--generator',
                                 type="string",
                                 help='Allows one to specify the generator type',
                                 default=self.generator )

    def process( self ):
        # Pre-seed the source root directory so we can load
        # the user's config file, which then allows us to build up
        # the actual argument parser
        src_root = os.getcwd()
        for i in range(0,len(sys.argv)):
            arg = sys.argv[i]
            if arg == "--source-dir":
                if (i + 1) < len(sys.argv):
                    src_root = os.path.abspath( sys.argv[i+1] )
            elif arg.startswith( "--source-dir=" ):
                src_root = os.path.abspath( arg.split('=')[1] )

        globs = {}
        for key, val in _iterate( globals() ):
            if key[0] != '_' and ( key == "os" or key == "sys" or key.lower() != key ):
                globs[key] = val

        self.root_dir = _Directory( src_root, "", None, None, globs )
        # Config pass is sort of special since user can potentially
        # register other phases, and we need to parse the options
        # after configuration
        self.cur_phase = self.phases[0]
        conf = self.phases[0].process_dir( self.root_dir )
        self.parse_options()

        if self.build_dir is None:
            self.build_dir = src_root

        if not isinstance( self.phases[len(self.phases) - 1], Generator ):
            global _generators
            self.phases.append( _generators[self.generator]() )

        for p in self.phases[1:]:
            self.cur_phase = p
            p.process_dir( self.root_dir )
        del(self.cur_phase)

    def add_phase( self, after, phase ):
        if not isinstance( phase, ProcessPhase ):
            Error( "Attempt to add processing phase, but need a subclass of ProcessPhase" )
        foundidx = -1
        for p in self.phases:
            if p.name == after:
                foundidx = idx
                break
        if foundidx < 0:
            Error( "Attempt to add processing phase after unknown phase '%s'" % after )
        self.phases.insert( foundidx + 1, phase )

    def add_feature( self, name, typename, help=None, default=None ):
        if self.user_features is not None:
            Error( "Invalid request to define feature '%s': All available features must be defined before testing to see if any are set" % name )

        if self.user_feature_defs is None:
            self.user_feature_defs = {}

        ## Hrm, set_defaults doesn't allow us to specify destinations
        ## by user argument string, so stash off for future use
        self.user_feature_defs[name] = [ typename, default ]

        if typename == "boolean":
            self.parser.add_option( '--enable-' + name,
                                     action="store_true",
                                     help="Enable " + help,
                                     dest=name )
            self.parser.add_option( '--disable-' + name,
                                     action="store_false",
                                     help="Disable " + help,
                                     dest=name )
        elif typename == "string":
            self.parser.add_option( '--' + name,
                                     type="string",
                                     help=help,
                                     dest=name,
                                     default=default )
        elif typename == "path":
            self.parser.add_option( '--' + name,
                                     type="string",
                                     help=help,
                                     metavar="PATH",
                                     dest=name,
                                     default=default )
        else:
            Error( "Unknown typename '%s' for user defined feature '%s'" % (typename, name) )

    def feature( self, name ):
        if self.user_features is None:
            self.parse_options()
        if name not in self.user_features:
            Error( "Unknown feature requested '%s', use DefineFeature first" % name )
        return self.user_features[name]

    def parse_options( self ):
        if self.user_features is not None:
            return
        (options, args) = self.parser.parse_args()

        if options.build is not None and len(options.build) > 0:
            self.build = options.build

        if options.build_dir is not None and len(options.build_dir) > 0:
            self.build_dir = options.build_dir
            
        if self.build_dir is None:
            self.build_dir = self.root_dir.src_dir

        self.generator = options.generator

        if len(self.build_set) == 0:
            Error( "Attempt to parse options triggered prior to any build configurations specified" )

        self.root_dir.set_bin_dir( os.path.abspath( os.path.join( self.build_dir, self.build_set[self.build] ) ) )

        self.user_features = {}
        if self.user_feature_defs is not None:
            for k, info in _iterate( self.user_feature_defs ):
                oVal = getattr( options, k, None )
                t = info[0]
                default = info[1]
                if t == "boolean":
                    if oVal is not None:
                        self.user_features[k] = oVal
                    else:
                        self.user_features[k] = default
                elif t == "string":
                    if oVal is not None:
                        self.user_features[k] = oVal
                    else:
                        self.user_features[k] = default
                elif t == "path":
                    if oVal is not None and len(oVal) > 0:
                        self.user_features[k] = os.path.abspath( oVal )
                    else:
                        self.user_features[k] = default
                else:
                    Error( "Attempt to parse user option '%s' with unknown type '%s'\n" % (k, t) )

    def add_config( self, tag, outloc, default ):
        self.build_set[tag] = outloc
        if default and self.build is None:
            self.build = tag

########################################
########################################


def FindOptionalExecutable( exe ):
    if exe is None:
        return None

    if sys.platform == "win32" or sys.platform == "win64":
        if exe[:-4] != ".exe":
            exe = exe + ".exe"
        pass

    is_exe = lambda fpath: os.path.isfile( fpath ) and os.access( fpath, os.X_OK )

    fpath, fname = os.path.split( exe )
    if fpath:
        if is_exe( exe ):
            return exe
    else:
        for path in os.environ["PATH"].split( os.pathsep ):
            path = path.strip( '"' )
            exe_file = os.path.join( path, exe )
            if is_exe( exe_file ):
                return exe_file
    return None

def FindExecutable( exe ):
    exe_file = FindOptionalExecutable( exe )
    if exe_file is None:
        raise OSError( errno.ENOENT, "No such file or directory trying to find executable", exe )
    return exe_file

# pkg-config may exist even under windows
_pkgconfig = FindOptionalExecutable( "pkg-config" )
_externResolvers = []
_externPackages = {}

def AddExternalResolver( f ):
    global _externResolvers
    _externResolvers.append( f )

def FindExternalLibrary( name, version=None ):
    global _pkgconfig
    global _externPackages
    global _externResolvers
    if _pkgconfig is not None:
        try:
            lib = name
            if version is not None:
                lib += " "
                lib += version
            ver = subprocess.check_output( [_pkgconfig, '--modversion', lib] )
            cflags = subprocess.check_output( [_pkgconfig, '--cflags-only-other', lib] )
            iflags = subprocess.check_output( [_pkgconfig, '--cflags-only-I', lib] )
            lflags = subprocess.check_output( [_pkgconfig, '--libs', lib] )
            e = _ExternalPackage( name=name, cflags=cflags, iflags=iflags, lflags=lflags, ver=ver )
            _externPackages[name] = e
            return e
        except:
            pass
    # still here, pkg-config failed
    # try the user provided external resolver if specified
    for e in _externResolver:
        try:
            retval = e( name, version )
            _externPackages[name] = retval
            if retval is not None:
                return retval
        except:
            pass

    # Nothing found so far, check system path
    if sys.platform == "win32" or sys.platform == "win64":
        raise NotImplementedError

    libso = os.path.join( 'usr', 'local', 'lib', 'lib' + name + '.so' )
    libstat = os.path.join( 'usr', 'local', 'lib', 'lib' + name + '.a' )
    if os.path.exists( libso ) or os.path.exists( libstat ):
        e = _ExternalPackage( name=name, iflags="-I /usr/local/include", lflags="-L /usr/local/lib -l" + name )
        _externPackages[name] = e
        return e

    libso = os.path.join( 'usr', 'lib', 'lib' + name + '.so' )
    libstat = os.path.join( 'usr', 'lib', 'lib' + name + '.a' )
    if os.path.exists( libso ) or os.path.exists( libstat ):
        e = _ExternalPackage( name=name, lflags="-l" + name )
        _externPackages[name] = e
        return e

    if sys.platform.startswith( 'darwin' ):
        Error( "Verify Framework Check" )
        frm = os.path.join( 'Library', 'Frameworks', name )
        if os.path.exists( frm ):
            e = _ExternalPackage( name=name,
                                  lflags="-framework " + name )
            _externPackages[name] = e
            return e

    # Nothing found
    return None

def HaveExternal( name ):
    global _externPackages
    if name in _externPackages:
        return True
    return False

def Info( msg ):
    sys.stdout.write( msg )
    sys.stdout.write( '\n' )
    sys.stdout.flush()

def Warning( msg ):
    sys.stderr.write( "WARNING: " )
    sys.stderr.write( msg )
    sys.stderr.write( '\n' )
    sys.stderr.flush()

def Error( msg ):
    sys.stderr.write( "ERROR: " )
    sys.stderr.write( msg )
    sys.stderr.write( '\n\n' )
    sys.stderr.flush()
    sys.exit( 1 )

def DefineFeature( name, typename, help=None, default=None ):
    _BuildTree._singleton.add_feature( name, typename, help, default )

def Feature( name ):
    return _BuildTree._singleton.feature( name )

def BuildConfig( tag, outloc, default = False ):
    _BuildTree._singleton.add_config( tag, outloc, default )

def AddGeneratorClass( name, classRef ):
    global _generators
    _generators[name] = classRef

def AddProcessingPhase( name, after, phase ):
    _BuildTree._singleton.add_phase( name, after, phase )

def SubDir( name ):
    _BuildTree._singleton.cur_phase.subdir( name )

def GetCurrentSourceDir():
    _BuildTree._singleton.parse_options()
    return _BuildTree._singleton.cur_phase.cur_dir.src_dir

def GetCurrentSourceRelDir():
    _BuildTree._singleton.parse_options()
    return _BuildTree._singleton.cur_phase.cur_dir.rel_src_dir

def GetBuildRootDir():
    _BuildTree._singleton.parse_options()
    return _BuildTree._singleton.root_dir.bin_path

def GetCurrentBinaryDir():
    _BuildTree._singleton.parse_options()
    return _BuildTree._singleton.cur_phase.cur_dir.bin_dir

def Building( b ):
    _BuildTree._singleton.parse_options()
    return _BuildTree._singleton.build == b

if __name__ == "__main__":
    _BuildTree().process()
